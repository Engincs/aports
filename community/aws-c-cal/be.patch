--- a/source/der.c
+++ b/source/der.c
@@ -81,14 +81,18 @@ static int s_der_read_tlv(struct aws_byte_cursor *cur, struct der_tlv *tlv) {
         len_bytes &= 0x7f;
         switch (len_bytes) {
             case 1:
-                if (!aws_byte_cursor_read_u8(cur, (uint8_t *)&len)) {
+                uint8_t len_u8;
+                if (!aws_byte_cursor_read_u8(cur, &len_u8)) {
                     return aws_raise_error(AWS_ERROR_CAL_MALFORMED_ASN1_ENCOUNTERED);
                 }
+                len = len_u8;
                 break;
             case 2:
-                if (!aws_byte_cursor_read_be16(cur, (uint16_t *)&len)) {
+                uint16_t len_u16;
+                if (!aws_byte_cursor_read_be16(cur, &len_u16)) {
                     return aws_raise_error(AWS_ERROR_CAL_MALFORMED_ASN1_ENCOUNTERED);
                 }
+                len = len_u16;
                 break;
             case 4:
                 if (!aws_byte_cursor_read_be32(cur, &len)) {
@@ -254,7 +258,8 @@ int aws_der_encoder_write_unsigned_integer(struct aws_der_encoder *encoder, stru
 }
 
 int aws_der_encoder_write_boolean(struct aws_der_encoder *encoder, bool boolean) {
-    struct der_tlv tlv = {.tag = AWS_DER_BOOLEAN, .length = 1, .value = (uint8_t *)&boolean};
+    uint8_t v = boolean;
+    struct der_tlv tlv = {.tag = AWS_DER_BOOLEAN, .length = 1, .value = &v};
 
     return s_der_write_tlv(&tlv, encoder->buffer);
 }
--- a/source/unix/opensslcrypto_hash.c
+++ b/source/unix/opensslcrypto_hash.c
@@ -158,14 +158,14 @@ static int s_finalize(struct aws_hash *hash, struct aws_byte_buf *output) {
 
     EVP_MD_CTX *ctx = hash->impl;
 
-    size_t buffer_len = output->capacity - output->len;
+    unsigned int buffer_len = output->capacity - output->len;
 
     if (buffer_len < hash->digest_size) {
         return aws_raise_error(AWS_ERROR_SHORT_BUFFER);
     }
 
     if (AWS_LIKELY(g_aws_openssl_evp_md_ctx_table->final_ex_fn(
-            ctx, output->buffer + output->len, (unsigned int *)&buffer_len))) {
+            ctx, output->buffer + output->len, &buffer_len))) {
         output->len += hash->digest_size;
         hash->good = false;
         return AWS_OP_SUCCESS;
--- a/source/unix/opensslcrypto_hmac.c
+++ b/source/unix/opensslcrypto_hmac.c
@@ -104,14 +104,14 @@ static int s_finalize(struct aws_hmac *hmac, struct aws_byte_buf *output) {
 
     HMAC_CTX *ctx = hmac->impl;
 
-    size_t buffer_len = output->capacity - output->len;
+    unsigned int buffer_len = output->capacity - output->len;
 
     if (buffer_len < hmac->digest_size) {
         return aws_raise_error(AWS_ERROR_SHORT_BUFFER);
     }
 
     if (AWS_LIKELY(
-            g_aws_openssl_hmac_ctx_table->final_fn(ctx, output->buffer + output->len, (unsigned int *)&buffer_len))) {
+            g_aws_openssl_hmac_ctx_table->final_fn(ctx, output->buffer + output->len, &buffer_len))) {
         hmac->good = false;
         output->len += hmac->digest_size;
         return AWS_OP_SUCCESS;
