Patch-Source: https://codeberg.org/superseriousbusiness/gotosocial/commit/a79f83cbded3fb1165b338ce316dc9f2217467ff
Backported for 1.19.1.
---
diff -ruN a/internal/cache/wrappers.go b/internal/cache/wrappers.go
--- a/internal/cache/wrappers.go	2025-05-06 14:29:32.000000000 +0000
+++ b/internal/cache/wrappers.go	2025-09-04 21:57:14.195571830 +0000
@@ -20,6 +20,7 @@
 import (
 	"slices"
 
+	"code.superseriousbusiness.org/gotosocial/internal/gtserror"
 	"codeberg.org/gruf/go-cache/v3/simple"
 	"codeberg.org/gruf/go-structr"
 )
@@ -27,19 +28,19 @@
 // SliceCache wraps a simple.Cache to provide simple loader-callback
 // functions for fetching + caching slices of objects (e.g. IDs).
 type SliceCache[T any] struct {
-	cache simple.Cache[string, []T]
+	simple.Cache[string, []T]
 }
 
 // Init initializes the cache with given length + capacity.
 func (c *SliceCache[T]) Init(len, cap int) {
-	c.cache = simple.Cache[string, []T]{}
-	c.cache.Init(len, cap)
+	c.Cache = simple.Cache[string, []T]{}
+	c.Cache.Init(len, cap)
 }
 
 // Load will attempt to load an existing slice from cache for key, else calling load function and caching the result.
 func (c *SliceCache[T]) Load(key string, load func() ([]T, error)) ([]T, error) {
 	// Look for cached values.
-	data, ok := c.cache.Get(key)
+	data, ok := c.Cache.Get(key)
 
 	if !ok {
 		var err error
@@ -51,7 +52,7 @@
 		}
 
 		// Store the data.
-		c.cache.Set(key, data)
+		c.Cache.Set(key, data)
 	}
 
 	// Return data clone for safety.
@@ -60,27 +61,7 @@
 
 // Invalidate: see simple.Cache{}.InvalidateAll().
 func (c *SliceCache[T]) Invalidate(keys ...string) {
-	_ = c.cache.InvalidateAll(keys...)
-}
-
-// Trim: see simple.Cache{}.Trim().
-func (c *SliceCache[T]) Trim(perc float64) {
-	c.cache.Trim(perc)
-}
-
-// Clear: see simple.Cache{}.Clear().
-func (c *SliceCache[T]) Clear() {
-	c.cache.Clear()
-}
-
-// Len: see simple.Cache{}.Len().
-func (c *SliceCache[T]) Len() int {
-	return c.cache.Len()
-}
-
-// Cap: see simple.Cache{}.Cap().
-func (c *SliceCache[T]) Cap() int {
-	return c.cache.Cap()
+	_ = c.Cache.InvalidateAll(keys...)
 }
 
 // StructCache wraps a structr.Cache{} to simple index caching
@@ -89,44 +70,36 @@
 // name under the main database caches struct which would reduce
 // time required to access cached values).
 type StructCache[StructType any] struct {
-	cache structr.Cache[StructType]
+	structr.Cache[StructType]
 	index map[string]*structr.Index
 }
 
 // Init initializes the cache with given structr.CacheConfig{}.
 func (c *StructCache[T]) Init(config structr.CacheConfig[T]) {
 	c.index = make(map[string]*structr.Index, len(config.Indices))
-	c.cache = structr.Cache[T]{}
-	c.cache.Init(config)
+	c.Cache = structr.Cache[T]{}
+	c.Cache.Init(config)
 	for _, cfg := range config.Indices {
-		c.index[cfg.Fields] = c.cache.Index(cfg.Fields)
+		c.index[cfg.Fields] = c.Cache.Index(cfg.Fields)
 	}
 }
 
 // GetOne calls structr.Cache{}.GetOne(), using a cached structr.Index{} by 'index' name.
 // Note: this also handles conversion of the untyped (any) keys to structr.Key{} via structr.Index{}.
 func (c *StructCache[T]) GetOne(index string, key ...any) (T, bool) {
-	i := c.index[index]
-	return c.cache.GetOne(i, i.Key(key...))
+	return c.Cache.GetOne(c.index[index], structr.MakeKey(key...))
 }
 
 // Get calls structr.Cache{}.Get(), using a cached structr.Index{} by 'index' name.
 // Note: this also handles conversion of the untyped (any) keys to structr.Key{} via structr.Index{}.
 func (c *StructCache[T]) Get(index string, keys ...[]any) []T {
-	i := c.index[index]
-	return c.cache.Get(i, i.Keys(keys...)...)
-}
-
-// Put: see structr.Cache{}.Put().
-func (c *StructCache[T]) Put(values ...T) {
-	c.cache.Put(values...)
+	return c.Cache.Get(c.index[index], structr.MakeKeys(keys...)...)
 }
 
 // LoadOne calls structr.Cache{}.LoadOne(), using a cached structr.Index{} by 'index' name.
 // Note: this also handles conversion of the untyped (any) keys to structr.Key{} via structr.Index{}.
 func (c *StructCache[T]) LoadOne(index string, load func() (T, error), key ...any) (T, error) {
-	i := c.index[index]
-	return c.cache.LoadOne(i, i.Key(key...), load)
+	return c.Cache.LoadOne(c.index[index], structr.MakeKey(key...), load)
 }
 
 // LoadIDs calls structr.Cache{}.Load(), using a cached structr.Index{} by 'index' name. Note: this also handles
@@ -134,28 +107,26 @@
 //
 // If you need to load multiple cache keys other than by ID strings, please create another convenience wrapper.
 func (c *StructCache[T]) LoadIDs(index string, ids []string, load func([]string) ([]T, error)) ([]T, error) {
-	i := c.index[index]
-	if i == nil {
-		// we only perform this check here as
-		// we're going to use the index before
-		// passing it to cache in main .Load().
-		panic("missing index for cache type")
-	}
 
 	// Generate cache keys for ID types.
 	keys := make([]structr.Key, len(ids))
+	if len(keys) != len(ids) {
+		panic(gtserror.New("BCE"))
+	}
 	for x, id := range ids {
-		keys[x] = i.Key(id)
+		keys[x] = structr.MakeKey(id)
 	}
 
-	// Pass loader callback with wrapper onto main cache load function.
-	return c.cache.Load(i, keys, func(uncached []structr.Key) ([]T, error) {
-		uncachedIDs := make([]string, len(uncached))
-		for i := range uncached {
-			uncachedIDs[i] = uncached[i].Values()[0].(string)
-		}
-		return load(uncachedIDs)
-	})
+	// Pass loader callback with
+	// wrapper onto main cache load function.
+	return c.Cache.Load(c.index[index], keys,
+		func(uncached []structr.Key) ([]T, error) {
+			uncachedIDs := make([]string, len(uncached))
+			for i := range uncached {
+				uncachedIDs[i] = uncached[i].Values()[0].(string)
+			}
+			return load(uncachedIDs)
+		})
 }
 
 // LoadIDs2Part works as LoadIDs, except using a two-part key,
@@ -172,12 +143,15 @@
 
 	// Generate cache keys for two-part IDs.
 	keys := make([]structr.Key, len(id2s))
+	if len(keys) != len(id2s) {
+		panic(gtserror.New("BCE"))
+	}
 	for x, id2 := range id2s {
-		keys[x] = i.Key(id1, id2)
+		keys[x] = structr.MakeKey(id1, id2)
 	}
 
 	// Pass loader callback with wrapper onto main cache load function.
-	return c.cache.Load(i, keys, func(uncached []structr.Key) ([]T, error) {
+	return c.Cache.Load(i, keys, func(uncached []structr.Key) ([]T, error) {
 		uncachedIDs := make([]string, len(uncached))
 		for i := range uncached {
 			uncachedIDs[i] = uncached[i].Values()[1].(string)
@@ -186,16 +160,10 @@
 	})
 }
 
-// Store: see structr.Cache{}.Store().
-func (c *StructCache[T]) Store(value T, store func() error) error {
-	return c.cache.Store(value, store)
-}
-
 // Invalidate calls structr.Cache{}.Invalidate(), using a cached structr.Index{} by 'index' name.
 // Note: this also handles conversion of the untyped (any) keys to structr.Key{} via structr.Index{}.
 func (c *StructCache[T]) Invalidate(index string, key ...any) {
-	i := c.index[index]
-	c.cache.Invalidate(i, i.Key(key...))
+	c.Cache.Invalidate(c.index[index], structr.MakeKey(key...))
 }
 
 // InvalidateIDs calls structr.Cache{}.Invalidate(), using a cached structr.Index{} by 'index' name. Note: this also
@@ -203,40 +171,17 @@
 //
 // If you need to invalidate multiple cache keys other than by ID strings, please create another convenience wrapper.
 func (c *StructCache[T]) InvalidateIDs(index string, ids []string) {
-	i := c.index[index]
-	if i == nil {
-		// we only perform this check here as
-		// we're going to use the index before
-		// passing it to cache in main .Load().
-		panic("missing index for cache type")
-	}
 
 	// Generate cache keys for ID types.
 	keys := make([]structr.Key, len(ids))
+	if len(keys) != len(ids) {
+		panic(gtserror.New("BCE"))
+	}
 	for x, id := range ids {
-		keys[x] = i.Key(id)
+		keys[x] = structr.MakeKey(id)
 	}
 
 	// Pass to main invalidate func.
-	c.cache.Invalidate(i, keys...)
-}
-
-// Trim: see structr.Cache{}.Trim().
-func (c *StructCache[T]) Trim(perc float64) {
-	c.cache.Trim(perc)
-}
-
-// Clear: see structr.Cache{}.Clear().
-func (c *StructCache[T]) Clear() {
-	c.cache.Clear()
-}
-
-// Len: see structr.Cache{}.Len().
-func (c *StructCache[T]) Len() int {
-	return c.cache.Len()
-}
-
-// Cap: see structr.Cache{}.Cap().
-func (c *StructCache[T]) Cap() int {
-	return c.cache.Cap()
+	c.Cache.Invalidate(c.index[index],
+		keys...)
 }
diff -ruN a/internal/queue/struct.go b/internal/queue/struct.go
--- a/internal/queue/struct.go	2025-05-06 14:29:32.000000000 +0000
+++ b/internal/queue/struct.go	2025-09-04 20:30:26.121230734 +0000
@@ -62,8 +62,7 @@
 
 // Delete pops (and drops!) all queued entries under index with key.
 func (q *StructQueue[T]) Delete(index string, key ...any) {
-	i := q.index[index]
-	_ = q.queue.Pop(i, i.Key(key...))
+	_ = q.queue.Pop(q.index[index], structr.MakeKey(key...))
 }
 
 // Len: see structr.Queue{}.Len().
